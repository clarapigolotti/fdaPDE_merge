rm(list=ls())
## Create a 2.5D mesh
data(sphereData)
sphere<-create.mesh.2.5D(sphere$nodes, sphere$triangles)
# Normalize the sphere
sum_square = sphere$nodes[,1]^2 + sphere$nodes[,2]^2 + sphere$nodes[,3]^2
sphere$nodes[,1] = sphere$nodes[,1]  / sqrt(sum_square)
sphere$nodes[,2] = sphere$nodes[,2]  / sqrt(sum_square)
sphere$nodes[,3] = sphere$nodes[,3]  / sqrt(sum_square)
FEMbasis <- create.FEM.basis(sphere)
## Generating data
library(Directional)
mu <- c(0.8, 0.8, 1)
mu <- mu / sqrt( sum(mu^2) )
k=10
beta=0
data <- rkent(100, k, mu, beta)
plot(sphere)
pch3d(data, pch=10, cex=0.1, col="red")
mu <- c(0, 0, 1)
mu <- mu / sqrt( sum(mu^2) )
k=10
beta=0
data <- rkent(100, k, mu, beta)
plot(sphere)
pch3d(data, pch=10, cex=0.1, col="red")
lambda = 0.01
sol <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda, fvec=NULL, heatStep=0.1,
heatIter=500, stepProposals=NULL, tol1=1e-4, tol2=0, print=FALSE, nThreads_int=2,
nThreads_l=1, nThreads_fold=1, nfolds=NULL, nsimulations=500,
step_method = "Fixed_Step", direction_method = "BFGS",
preprocess_method="NoCrossValidation")
## Visualization
plot(FEM(exp(sol$g), FEMbasis))
# 1) Cross-validation
lambda = c(0.0001, 0.001, 0.01, 0.1)
nfolds = 5
sol <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda, fvec=NULL, heatStep=0.1,
heatIter=500, stepProposals=NULL, tol1=1e-4, tol2=0, print=FALSE, nThreads_int=2,
nThreads_l=1, nThreads_fold=1, nfolds=nfolds, nsimulations=500,
step_method = "Fixed_Step", direction_method = "BFGS",
preprocess_method="RightCV")
sol$lambda
## Visualization
plot(FEM(exp(sol$g), FEMbasis))
## Generating data
library(Directional)
mu <- c(0, 1, 0)
mu <- mu / sqrt( sum(mu^2) )
k=10
beta=0
data <- rkent(100, k, mu, beta)
plot(sphere)
pch3d(data, pch=10, cex=0.1, col="red")
mu <- c(0, -1, 0)
mu <- mu / sqrt( sum(mu^2) )
k=10
beta=0
data <- rkent(100, k, mu, beta)
plot(sphere)
pch3d(data, pch=10, cex=0.1, col="red")
lambda = 0.01
sol <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda, fvec=NULL, heatStep=0.1,
heatIter=500, stepProposals=NULL, tol1=1e-4, tol2=0, print=FALSE, nThreads_int=2,
nThreads_l=1, nThreads_fold=1, nfolds=NULL, nsimulations=500,
step_method = "Fixed_Step", direction_method = "BFGS",
preprocess_method="NoCrossValidation")
## Visualization
plot(FEM(exp(sol$g), FEMbasis))
plot(sphere)
pch3d(data, pch=10, cex=0.1, col="red")
pch3d(sol$data, pch=10, cex=0.1, col="blue")
plot(sphere)
pch3d(data, pch=19, cex=0.1, col="red")
pch3d(sol$data, pch=19, cex=0.1, col="blue")
# 3D -------------------------------------------
rm(list=ls())
library(mvtnorm)
## Create a 3D mesh
data(sphere3Ddata)
sphere3D<-create.mesh.3D(sphere3Ddata$nodes, sphere3Ddata$tetrahedrons)
#plot(sphere3D)
FEMbasis <- create.FEM.basis(sphere3D)
## Generate data
fact = 0.01
sigma <- fact * diag(3)
mu <- c(0,0,0)
data <- rmvnorm(100, mean=mu, sigma=sigma)
lambda = 1e-5
sol <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda, fvec=NULL, heatStep=0.1,
heatIter=500, stepProposals=NULL, tol1=1e-4, tol2=0, print=FALSE, nThreads_int=2,
nThreads_l=1, nThreads_fold=1, nfolds=NULL, nsimulations=500,
step_method = "Fixed_Step", direction_method = "BFGS",
preprocess_method="NoCrossValidation")
## Visualization
plot(FEM(exp(sol$g), FEMbasis))
# 2D ------------------
rm(list=ls())
graphics.off()
remove.packages("fdaPDE")
# Documentation
setwd("/home/clara/Documenti/fdaPDE_versioneCompleta/fdaPDE_merge")
roxygen2::roxygenise()
# fadPDE merge
install.packages("/home/clara/Documenti/fdaPDE_versioneCompleta/fdaPDE_merge", type="source", repos=NULL)
library(fdaPDE)
data(simpleMesh2Ddata)
mesh<-create.mesh.2D(nodes = nodes,triangles = triangles)
FEMbasis=create.FEM.basis(mesh)
eigenfunc1=FEM(sin(2*pi*mesh$nodes[,1]), FEMbasis)
eigenfunc2=FEM(cos(2*pi*mesh$nodes[,1]), FEMbasis)
eigenfunc3=FEM(cos(2*pi*mesh$nodes[,2]), FEMbasis)
plot(eigenfunc1)
truedatarange<-max(c(eigenfunc1$coeff,eigenfunc2$coeff,eigenfunc3$coeff))-min(c(eigenfunc1$coeff,eigenfunc2$coeff,eigenfunc3$coeff))
truecoeff<-cbind(eigenfunc1$coeff,eigenfunc2$coeff,eigenfunc3$coeff)
set.seed(5847947)
nSamples=50
sd_score1<-0.1
sd_score2<-0.05
sd_score3<-0.03
sd_error<-0.05
score1<-rnorm(n=nSamples,sd=sd_score1*truedatarange)
score2<-rnorm(n=nSamples,sd=sd_score2*truedatarange)
score3<-rnorm(n=nSamples,sd=sd_score3*truedatarange)
datamatrix.pointwise.exact<-matrix(score1)%*%t(matrix(eigenfunc1$coeff))+matrix(score2)%*%t(matrix(eigenfunc2$coeff))+matrix(score3)%*%t(matrix(eigenfunc3$coeff))
dm.pointwise.centred.exact<-datamatrix.pointwise.exact-matrix(apply(datamatrix.pointwise.exact,2,mean),ncol=ncol(datamatrix.pointwise.exact),nrow=nrow(datamatrix.pointwise.exact),byrow=TRUE)
lambda=10^c(-6,-5,-4,-3,-2)
validation='KFold'
nfolds=5
GCVMETHOD='Stochastic'
nnodes=dim(mesh$nodes)[1]
error<-rnorm(n=nSamples*nnodes,sd=sd_error*truedatarange)
datamatrix.pointwise<-datamatrix.pointwise.exact+error
dm.pointwise.centred<-datamatrix.pointwise-matrix(apply(datamatrix.pointwise,2,mean),ncol=ncol(datamatrix.pointwise),nrow=nrow(datamatrix.pointwise),byrow=TRUE)
sol.pointwise<-FPCA.FEM(datamatrix=dm.pointwise.centred,FEMbasis=FEMbasis,lambda=lambda,nPC=3,validation=validation,GCVmethod=GCVMETHOD, NFolds = nfolds)
plot(sol.pointwise$loadings.FEM)
sol.pointwise$treeFEMbasis
# 3D -------------------------------------------
rm(list=ls())
remove.packages("fdaPDE")
# fadPDE merge
install.packages("/home/clara/Documenti/fdaPDE_versioneCompleta/fdaPDE_merge", type="source", repos=NULL)
library(fdaPDE)
# 2D ------------------
rm(list=ls())
graphics.off()
## Create a 2D mesh over a squared domain
Xbound <- seq(-3, 3, length.out = 10)
Ybound <- seq(-3, 3, length.out = 10)
grid_XY <- expand.grid(Xbound, Ybound)
Bounds <- grid_XY[(grid_XY$Var1 %in% c(-3, 3)) | (grid_XY$Var2 %in% c(-3, 3)), ]
mesh <- create.mesh.2D(nodes = Bounds, order = 1)
mesh <- refine.mesh.2D(mesh, maximum_area = 0.2)
FEMbasis <- create.FEM.basis(mesh)
set.seed(10)
## Generate data
n <- 50
data_x <- rnorm(n)
data_y <- rnorm(n)
data <- cbind(data_x, data_y)
# 2) Lambda fixed
lambda = 0.1
sol <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda,
step_method = "Fixed_Step", direction_method = "BFGS",
preprocess_method="NoCrossValidation")
## Visualization
image(FEM(exp(sol$g), FEMbasis))
class(FEMbasis)
# 2D ------------------
rm(list=ls())
graphics.off()
# Documentation
setwd("/home/clara/Documenti/fdaPDE_versioneCompleta/fdaPDE_merge")
roxygen2::roxygenise()
# fadPDE merge
install.packages("/home/clara/Documenti/fdaPDE_versioneCompleta/fdaPDE_merge", type="source", repos=NULL)
library(fdaPDE)
# 2D ------------------
rm(list=ls())
graphics.off()
## Create a 2D mesh over a squared domain
Xbound <- seq(-3, 3, length.out = 10)
Ybound <- seq(-3, 3, length.out = 10)
grid_XY <- expand.grid(Xbound, Ybound)
Bounds <- grid_XY[(grid_XY$Var1 %in% c(-3, 3)) | (grid_XY$Var2 %in% c(-3, 3)), ]
mesh <- create.mesh.2D(nodes = Bounds, order = 1)
mesh <- refine.mesh.2D(mesh, maximum_area = 0.2)
FEMbasis <- create.FEM.basis(mesh)
set.seed(10)
## Generate data
n <- 50
data_x <- rnorm(n)
data_y <- rnorm(n)
data <- cbind(data_x, data_y)
lambda = c(0.001, 0.01, 0.1, 1)
nfolds = 5
sol <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda, nfolds=nfolds,
step_method = "Fixed_Step", direction_method = "BFGS",
preprocess_method="RightCV")
sol$lambda
sol$lambda
# 2) Lambda fixed
lambda = 0.1
sol <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda,
step_method = "Fixed_Step", direction_method = "BFGS",
preprocess_method="NoCrossValidation")
# 2.5D -------------
rm(list=ls())
## Create a 2.5D mesh
data(sphereData)
sphere<-create.mesh.2.5D(sphere$nodes, sphere$triangles)
# Normalize the sphere
sum_square = sphere$nodes[,1]^2 + sphere$nodes[,2]^2 + sphere$nodes[,3]^2
sphere$nodes[,1] = sphere$nodes[,1]  / sqrt(sum_square)
sphere$nodes[,2] = sphere$nodes[,2]  / sqrt(sum_square)
sphere$nodes[,3] = sphere$nodes[,3]  / sqrt(sum_square)
FEMbasis <- create.FEM.basis(sphere)
## Generating data
library(Directional)
mu <- c(0, -1, 0)
mu <- mu / sqrt( sum(mu^2) )
k=10
beta=0
data <- rkent(100, k, mu, beta)
## Density Estimation:
lambda = 0.01
sol <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda, fvec=NULL, heatStep=0.1,
heatIter=500, stepProposals=NULL, tol1=1e-4, tol2=0, print=FALSE, nThreads_int=2,
nThreads_l=1, nThreads_fold=1, nfolds=NULL, nsimulations=500,
step_method = "Fixed_Step", direction_method = "BFGS",
preprocess_method="NoCrossValidation")
# 2.5D -------------
rm(list=ls())
remove.packages("fdaPDE")
# fadPDE merge
install.packages("/home/clara/Documenti/fdaPDE_versioneCompleta/fdaPDE_merge", type="source", repos=NULL)
library(fdaPDE)
rm(list=ls())
graphics.off()
## Create a 2D mesh over a squared domain
Xbound <- seq(-3, 3, length.out = 10)
Ybound <- seq(-3, 3, length.out = 10)
grid_XY <- expand.grid(Xbound, Ybound)
Bounds <- grid_XY[(grid_XY$Var1 %in% c(-3, 3)) | (grid_XY$Var2 %in% c(-3, 3)), ]
mesh <- create.mesh.2D(nodes = Bounds, order = 1)
mesh <- refine.mesh.2D(mesh, maximum_area = 0.2)
FEMbasis <- create.FEM.basis(mesh)
set.seed(10)
## Generate data
n <- 50
data_x <- rnorm(n)
data_y <- rnorm(n)
data <- cbind(data_x, data_y)
## Density Estimation:
# 2) Lambda fixed
lambda = 0.1
sol <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda,
step_method = "Fixed_Step", direction_method = "BFGS",
preprocess_method="NoCrossValidation")
# 2D ------------------
rm(list=ls())
graphics.off()
remove.packages("fdaPDE")
# fadPDE merge
install.packages("/home/clara/Documenti/fdaPDE_versioneCompleta/fdaPDE_merge", type="source", repos=NULL)
library(fdaPDE)
## Create a 2D mesh over a squared domain
Xbound <- seq(-3, 3, length.out = 10)
Ybound <- seq(-3, 3, length.out = 10)
grid_XY <- expand.grid(Xbound, Ybound)
Bounds <- grid_XY[(grid_XY$Var1 %in% c(-3, 3)) | (grid_XY$Var2 %in% c(-3, 3)), ]
mesh <- create.mesh.2D(nodes = Bounds, order = 1)
mesh <- refine.mesh.2D(mesh, maximum_area = 0.2)
FEMbasis <- create.FEM.basis(mesh)
set.seed(10)
## Generate data
n <- 50
data_x <- rnorm(n)
data_y <- rnorm(n)
data <- cbind(data_x, data_y)
# 3) Cross-validation simplified version
lambda = c(0.0001, 0.001, 0.01, 0.1, 1)
nfolds = 5
sol <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda, nfolds=nfolds,
step_method = "Fixed_Step", direction_method = "BFGS",
preprocess_method="SimplifiedCV")
# 2D ------------------
rm(list=ls())
graphics.off()
remove.packages("fdaPDE")
# fadPDE merge
install.packages("/home/clara/Documenti/fdaPDE_versioneCompleta/fdaPDE_merge", type="source", repos=NULL)
# fadPDE merge
install.packages("/home/clara/Documenti/fdaPDE_versioneCompleta/fdaPDE_merge", type="source", repos=NULL)
library(fdaPDE)
## Create a 2D mesh over a squared domain
Xbound <- seq(-3, 3, length.out = 10)
Ybound <- seq(-3, 3, length.out = 10)
grid_XY <- expand.grid(Xbound, Ybound)
Bounds <- grid_XY[(grid_XY$Var1 %in% c(-3, 3)) | (grid_XY$Var2 %in% c(-3, 3)), ]
mesh <- create.mesh.2D(nodes = Bounds, order = 1)
mesh <- refine.mesh.2D(mesh, maximum_area = 0.2)
FEMbasis <- create.FEM.basis(mesh)
set.seed(10)
## Generate data
n <- 50
data_x <- rnorm(n)
data_y <- rnorm(n)
data <- cbind(data_x, data_y)
# 2) Lambda fixed
lambda = 0.1
sol <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda,
step_method = "Fixed_Step", direction_method = "BFGS",
preprocess_method="NoCrossValidation")
# 2D ------------------
rm(list=ls())
graphics.off()
remove.packages("fdaPDE")
# fadPDE merge
install.packages("/home/clara/Documenti/fdaPDE_versioneCompleta/fdaPDE_merge", type="source", repos=NULL)
library(fdaPDE)
## Create a 2D mesh over a squared domain
Xbound <- seq(-3, 3, length.out = 10)
Ybound <- seq(-3, 3, length.out = 10)
grid_XY <- expand.grid(Xbound, Ybound)
Bounds <- grid_XY[(grid_XY$Var1 %in% c(-3, 3)) | (grid_XY$Var2 %in% c(-3, 3)), ]
mesh <- create.mesh.2D(nodes = Bounds, order = 1)
mesh <- refine.mesh.2D(mesh, maximum_area = 0.2)
FEMbasis <- create.FEM.basis(mesh)
set.seed(10)
## Generate data
n <- 50
data_x <- rnorm(n)
data_y <- rnorm(n)
data <- cbind(data_x, data_y)
# 2) Lambda fixed
lambda = 0.1
sol <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda,
step_method = "Fixed_Step", direction_method = "BFGS",
preprocess_method="NoCrossValidation")
sol$CV_err
sol$treeFEMbasis
sol$treeFEMbasis$transf_coord
sol$treeFEMbasis$mesh$treelev
sol$treeFEMbasis$mesh$header_orig
sol$treeFEMbasis$mesh$header_scale
sol$treeFEMbasis$mesh$node_id
sol$treeFEMbasis$mesh$node_left_child
sol$treeFEMbasis$mesh$node_right_child
sol$treeFEMbasis$mesh$node_box
# 2D ------------------
rm(list=ls())
graphics.off()
## Create a 2D mesh over a squared domain
Xbound <- seq(-3, 3, length.out = 10)
Ybound <- seq(-3, 3, length.out = 10)
grid_XY <- expand.grid(Xbound, Ybound)
Bounds <- grid_XY[(grid_XY$Var1 %in% c(-3, 3)) | (grid_XY$Var2 %in% c(-3, 3)), ]
mesh <- create.mesh.2D(nodes = Bounds, order = 1)
mesh <- refine.mesh.2D(mesh, maximum_area = 0.2)
FEMbasis <- create.FEM.basis(mesh)
set.seed(10)
## Generate data
n <- 50
data_x <- rnorm(n)
data_y <- rnorm(n)
data <- cbind(data_x, data_y)
## Density Estimation:
# 1) Cross-validation
lambda = c(0.001, 0.01, 0.1, 1)
nfolds = 5
sol <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda, nfolds=nfolds,
step_method = "Fixed_Step", direction_method = "BFGS",
preprocess_method="RightCV")
sol$CV_err
# 2D ------------------
rm(list=ls())
graphics.off()
search = 2
is.numeric(search)
rm(list=ls())
remove.packages("fdaPDE")
# Documentation
setwd("/home/clara/Documenti/fdaPDE_versioneCompleta/fdaPDE_merge")
roxygen2::roxygenise()
# Documentation
setwd("/home/clara/Documenti/fdaPDE_versioneCompleta/fdaPDE_merge")
roxygen2::roxygenise()
# fadPDE merge
install.packages("/home/clara/Documenti/fdaPDE_versioneCompleta/fdaPDE_merge", type="source", repos=NULL)
library(fdaPDE)
## Create a 2D mesh over a squared domain
Xbound <- seq(-3, 3, length.out = 10)
Ybound <- seq(-3, 3, length.out = 10)
grid_XY <- expand.grid(Xbound, Ybound)
Bounds <- grid_XY[(grid_XY$Var1 %in% c(-3, 3)) | (grid_XY$Var2 %in% c(-3, 3)), ]
mesh <- create.mesh.2D(nodes = Bounds, order = 1)
mesh <- refine.mesh.2D(mesh, maximum_area = 0.2)
FEMbasis <- create.FEM.basis(mesh)
set.seed(10)
## Generate data
n <- 50
data_x <- rnorm(n)
data_y <- rnorm(n)
data <- cbind(data_x, data_y)
# 2) Lambda fixed
lambda = 0.1
sol <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda,
step_method = "Fixed_Step", direction_method = "BFGS",
preprocess_method="NoCrossValidation")
# 2D ------------------
rm(list=ls())
graphics.off()
remove.packages("fdaPDE")
# fadPDE merge
install.packages("/home/clara/Documenti/fdaPDE_versioneCompleta/fdaPDE_merge", type="source", repos=NULL)
library(fdaPDE)
library(fdaPDE)
## Create a 2D mesh over a squared domain
Xbound <- seq(-3, 3, length.out = 10)
Ybound <- seq(-3, 3, length.out = 10)
grid_XY <- expand.grid(Xbound, Ybound)
Bounds <- grid_XY[(grid_XY$Var1 %in% c(-3, 3)) | (grid_XY$Var2 %in% c(-3, 3)), ]
mesh <- create.mesh.2D(nodes = Bounds, order = 1)
mesh <- refine.mesh.2D(mesh, maximum_area = 0.2)
FEMbasis <- create.FEM.basis(mesh)
set.seed(10)
## Generate data
n <- 50
data_x <- rnorm(n)
data_y <- rnorm(n)
data <- cbind(data_x, data_y)
# 2) Lambda fixed
lambda = 0.1
sol <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda,
step_method = "Fixed_Step", direction_method = "BFGS",
preprocess_method="NoCrossValidation")
## Visualization
image(FEM(exp(sol$g), FEMbasis))
# 8) Naive search algorithm
lambda = 0.1
sol <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda,
step_method = "Fixed_Step", direction_method = "BFGS",
preprocess_method="NoCrossValidation", search = 1)
## Visualization
image(FEM(exp(sol$g), FEMbasis))
# 2.5D -------------
rm(list=ls())
remove.packages("fdaPDE")
# fadPDE merge
install.packages("/home/clara/Documenti/fdaPDE_versioneCompleta/fdaPDE_merge", type="source", repos=NULL)
library(fdaPDE)
## Create a 2D mesh over a squared domain
Xbound <- seq(-3, 3, length.out = 10)
Ybound <- seq(-3, 3, length.out = 10)
grid_XY <- expand.grid(Xbound, Ybound)
Bounds <- grid_XY[(grid_XY$Var1 %in% c(-3, 3)) | (grid_XY$Var2 %in% c(-3, 3)), ]
mesh <- create.mesh.2D(nodes = Bounds, order = 1)
mesh <- refine.mesh.2D(mesh, maximum_area = 0.2)
FEMbasis <- create.FEM.basis(mesh)
set.seed(10)
n <- 50
data_x <- rnorm(n)
data_y <- rnorm(n)
data <- cbind(data_x, data_y)
lambda = 0.1
sol <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda,
step_method = "Fixed_Step", direction_method = "BFGS",
preprocess_method="NoCrossValidation")
## Visualization
image(FEM(exp(sol$g), FEMbasis))
lambda = 0.1
sol <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda,
step_method = "Fixed_Step", direction_method = "BFGS",
preprocess_method="NoCrossValidation", search = 1)
## Visualization
image(FEM(exp(sol$g), FEMbasis))
# 2.5D -------------
rm(list=ls())
# Documentation
setwd("/home/clara/Documenti/fdaPDE_versioneCompleta/fdaPDE_merge")
roxygen2::roxygenise()
# fadPDE merge
install.packages("/home/clara/Documenti/fdaPDE_versioneCompleta/fdaPDE_merge", type="source", repos=NULL)
library(fdaPDE)
library(fdaPDE)
## Create a 2D mesh over a squared domain
Xbound <- seq(-3, 3, length.out = 10)
Ybound <- seq(-3, 3, length.out = 10)
grid_XY <- expand.grid(Xbound, Ybound)
Bounds <- grid_XY[(grid_XY$Var1 %in% c(-3, 3)) | (grid_XY$Var2 %in% c(-3, 3)), ]
mesh <- create.mesh.2D(nodes = Bounds, order = 1)
mesh <- refine.mesh.2D(mesh, maximum_area = 0.2)
FEMbasis <- create.FEM.basis(mesh)
set.seed(10)
## Generate data
n <- 50
data_x <- rnorm(n)
data_y <- rnorm(n)
data <- cbind(data_x, data_y)
# 2) Lambda fixed
lambda = 0.1
sol <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda,
step_method = "Fixed_Step", direction_method = "BFGS",
preprocess_method="NoCrossValidation")
# 8) Naive search algorithm
lambda = 0.1
sol <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda,
step_method = "Fixed_Step", direction_method = "BFGS",
preprocess_method="NoCrossValidation", search = 1)
# 2.5D -------------
rm(list=ls())
